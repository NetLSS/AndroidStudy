# 19. 안드로이드 앱과 액티비티 생명주기

- 모바일 환경은 컴퓨터 환경보다 제한된 리소스를 갖는게 현실이다.
- 이와 관련해서 모바일 장치에서는 제한된 리소스를 고려해야한다.
- 메모리 특히 그런데 인드로이드 시스템에서는 제한된 리소스를 효율적으로 관리해야하는 의무가 있다.
- 운영체제 뿐 아니라 앱 모두에서
- 안드로이드는 앱이 실행되는 프로세스와 앱을 구성하는 모든 컴포넌트의 생명주기와 상태를 전적으로 통제한다.

## 안드로이드 앱과 리소스 관리

- 안드로이드 앱은 os 관리하에 별개의 프로세스로 실행됨
- 장치의 자원이 한계에 다다를 경우 메모리 확보를 위해서 프로세스를 중단하는 조치를 취하게된다.
- 종료시킬 때는 실행 중인 모든 프로세스의 우선순위와 상태를 고려한다.
- 이 둘을 조합해서 중요도 서열을 만든다.
- 충분한 리소스가 확보될 때까지 중요도 서열을 따라 프로세스를 종료 하게 된다.

## 안드로이드 프로세스 상태

- 앱은 프로세스로 실행되고 컴포넌트로 구성된다.
- 현재상태는 앱 내부에서 가장 높은 우선순위로 실행 중인 컴포넌트에 의해 정의된다.
- 우선순위
  1. 포그라운드 프로세스
  2. 가시적 프로세스
  3. 서비스 프로세스
  4. 백그라운드 프로세스
  5. 비어있는 프로세스

### 포그라운드 프로세스

- 화면으로 볼 수 있고
- 사용자와 상호작용을 하는 프로세스
- 가장 우선순위가 높음
- 포그라운드 프로세스가 되려면?
  - 사용자와 상호작용 중인 액티비티를 호스팅한다.
  - 사용자와 상호작용 중인 액티비티에 연결된 서비스를 호스팅한다.
  - 중단되면 사용자에게 해를 끼칠 수 있다는 것을 startForeground() 함수를 호출하여 알려준 서비스를 호출한다.
  - 자신의 onCreate(), onResume(), onStart() 콜백 함수 중 하나를 실행하는 서비스를 호스팅한다.
  - onReceive() 함수를 현재 실행중인 브로드캐스트 수신자를 호스팅한다.

### 가시적 프로세스

- 볼 수는 있지만 상호작용은 하지 않는 엑티비티를 포함하는 프로세스
- 이 앱의 화면 일부를 다른 액티비티가 포그라운드로 실행되면서가리는 경우.
- 이와 결합된 액티비티와 결합된 서비스를 호스팅하는 프로세스도 가시적 상태가 될 수 있음.

### 서비스 프로세스

- 이미 시작되어 현재 실행중인 서비스를 포함하는 프로세스

### 백그라운드 프로세스

- 사용자가 현재 볼 수 없는 하나 이상의 액티비티를 포함하는 프로세스.

### 비어있는 프로세스

- 실행되는 앱을 포함하지 않는 프로세스
- 새로 론치되는 앱을 호스팅하기 위해 메모리에 남아있음.
- 승객을 기다리는 버스와 비슷

## 액티비티 생명주기

- 프로세스 상태는 자신이 호스팅하는 앱을 구성하는 액티비티와 컴포넌트의 상태에 의해 결정
- 액티비티도 여러 상태가 있음
- 액티비티 스택안에 위치에 따라 결정된다

## 액티비티 스택

- 각 앱에 대해 액티비티 스택을 관리하고 유지한다.
- 앱 론칭시 첫번째 액티비티가 스택에 놓임
- 두번쨰 액티비티 실행시 스택의 맨위에 두번째 액티비티가 쌓임
- 스택 맨위 액티비티를 활성화된 액티비티 라고 함.
- 종료(뒤로가기)시 스택에서 빠지고 그 밑에 있던 액티비티가 나타난다.
- 빠져나간 액티비티는 런타임 시스템에 의해 제거되고 소멸된다.
- 시스템 리소스가 부족한 경우 스택의 제일 밑에 있는 액티비티 부터 제거됨.

## 액티비티 상태

- 앱에서 실행되는 동안 액티비티는 아래 상태중 하나가될 수 있음
- 실행(Active, Running) - 액티비티가 액티비티 스택의 맨위에 있고, 장치 화면에서 볼 수 있는 포그라운드 테스크 이며, 사용자와 현재 상호작용 하고 있다.
- 일시 중지(Paused) - 사용자가 화면에서 볼 수는 있지만 포커스가 없는 경우. 다른 액티비티에 의해 일부가 가린경우. 이 경우 메모리에 보존, 윈도우 매니저에 연결된 채로 있으며, 자신의 모든 상태 정보를 갖는다. 즉 복원시 빨리 복원 가능
- 중단(Stopped) - 액티비티가 사용자에게 보이지 않는다. 화면에서 액티비티 전체를 다른 액티비티가 가리고 있을 때. 모든 상태를 보존 하고 있긴하지만 시스템 메모리가 부족할 경우 종료될 수 있음
- 소멸(Killed) - 메모리 확보를 위해 런타임에 의해 액티비티가 종료됨. 

## 구성 변경

- 런타임이 리소스 확보를 위해 액티비티를 종료시킬 때 외에도
- 화면에 나타나는 액티비티 모습에 영향을 주는 모든 구헝 변경 (장치 회전, 시스템 폰트 설정) 등 은 액티비티 인스턴스를 소멸시키고 새로 생성하게함.
- 이것이 가장 빠른 방법이기 때문에 그렇다.
- 특정 구성 변경시에 다시 시작하지 않도록 설정할 수도 있음
  
## 상태 변경 처리

- 앱에 포함된 컴포넌트는 앱에 샐애 동안 여러 상태를 가짐.
- 이런 상태 변경을 런타임에 의해 앱에서 반응할 수 있게 알려준다.
- 상태 변경이 생길 때는 앱 내부의 데이터 구조와 사용자 인터페이스 상태 모두 저장 또는 복원하는 것이 필요하다.
- 앱에 포함된 객체의 생명주기 상태 변경을 처리하는 방법 2가지
  - 1. 안드로이드 운영체제가 호출해주는 상태 변경함수 사용하여 응답 (익히 알고 있는 onCreate, onStop 등)
  - 2. 구글에서 권장하는 새로운 방법인 Jetpack 의 ACC에 포함된 생명주기 클래스 사용하는 것

