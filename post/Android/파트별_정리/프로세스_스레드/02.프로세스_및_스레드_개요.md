# 프로세스 및 스레드 개요

앱 컴포넌트가 최초로 시작되면(해당 앱의 실행중인 컴포넌트가 없으면)
Android 시스템은 **하나의 실행 스레드**로 앱의 리눅스 프로세스를 시작합니다.

기본적으로 같은 앱의 모든 구성요소는 같은 프로세스와 스레드에서 실행됩니다.("main" 스레드)

실행하려는 앱 컴포넌트의 관련 다른 컴포넌트가 존재한다면 해당 앱의 프로세스가 이미 존재할 것이기 때문에
해당 컴포넌트는 프로세스 내에서 시작되고 같은 실행 스레드를 사용합니다.

하지만 앱 내의 여러 구성 요소가 각자 별도의 프로세스에서 실행되도록 할 수 있고,
어떤 프로세스라도 추가적으로 스레드를 생성할 수 있습니다.

해당 글은 프로세스와 스레드가 Android 앱에서 작동하는 방식을 설명합니다.

## 프로세스 

기본적으로 같은 앱의 모든 구성 요소는 같은 프로세스와 스레드에서 실행됩니다.
또 대부분의 앱에서는 이를 바꿔서는 안됩니다.
하지만 어떤 프로세스가 특정 구성요소에 속하는지 확인해야하는 경우에는 매니페스트 파일에서 확인이 가능합니다.

안드로이드 컴포넌트 유형 (activity, service, receiver, provider) 에 대한 매니페이스 항목은
해당 구성 요소가 실행되는 프로세스를 지정 가능한 ```android:process``` 속성을 지원합니다.

이러한 속성을 설정해서 각 컴포넌트를 자체 프로세스에서 실행하거나 일부 컴포넌트 요소만
프로세스를 공유하게 할 수 있습니다.

또한, ```android:process``` 를 설정하여 다른 앱의 컴포넌트를 동일한 프로세스에서 실행할 수도 있습니다.
단, 이는 앱이 동일한 리눅스 사용자 ID를 공유하고 동일한 인증서로 서명되었을 경우에 한합니다.

```<application>``` 요소도 ```android:process``` 특성을 지원하여, 모든 컴포넌트에 적용되는 Default 값을 설정할 수 있습니다.

Android 는 어느 시점에 프로세스를 종료하도록 결정할 수 있습니다. 
즉, 메모리가 부족하거나, 사용자에게 더욱 즉각적으로 서비스를 제공하는 프로세스가 기존 프로세스를 중단해야하는 경우 등이 있습니다.

그러면 중단된 프로세스에서 실행하고 있던 앱 컴포넌트도 같이 소멸됩니다.
그와 같은 컴포넌트에 수행할 작업이 다시 생기면 그에 대한 프로세스도 다시 시작됩니다.

어떤 프로세스를 종료할지 결정할 때 Android 시스템은 사용자에 대한 이들의 상대적 중요성을 판단합니다. (우선순위)
예를 들면 화면에 보이고 있는 컴포넌트를 포함한 프로세스를 종료하기 보다는 화면에 보이지 않는 컴포넌트(를 우선으로 가진)프로세스를 kill 합니다.
이때 프로세스의 종료를 결정하는 것은 해당 프로세스에서 실행되는 컴포넌트의 상태에 따라 달라집니다.

[프로세스 및 앱 수명주기](https://developer.android.com/guide/topics/processes/process-lifecycle?authuser=1)

> 잠깐 참고
- 안드로이드 4대 핵심 컴포넌트
  1. 엑티비티 : 화면 UI를 담당하는 컴포넌트
  2. 브로드케스트 리시버 : 시스템 또는 사용자가 발생시키는 메세지를 수신하는 컴포넌트
  3. 서비스 : 백그라운드 코드 처리를 담당하는 컴포넌트 (화면이 없는 엑티비티 라고 보면 되겠다)
  4. 컨텐츠 프로바이더 : 앱 끼리 데이터를 공유하기 위한 컴포넌트
- 컴포넌트 사용을 위한 도구
  1. 인텐트 : 엑티비티, 브로드케스트 리시버, 서비스를 실행하기 위해 시스템에 전달되는 메세지 도구
  2. 컨텐츠 리졸버 : 컨텐츠 프로바이더가 제공하는 데이터를 사용하기 위한 도구
- 컴포넌트는 독립적인 생명 주기에 의해서 실행된다.

## 스레드

앱이 시작되면 시스템이 앱에 대한 실행 스레드를 생성합니다. (main 스레드)

이 스레드는 Drawable 이벤트를 포함하여 적절한 사용자 인터페이스 위젯에 이벤트를 발송(디스패칭)하는 역할을 하기 때문에 매우 중요합니다.

대부분의 경우 이것은 Android UI 툴킷의 컴포넌트(```android.widget```과 ```android.view```패키지의 구성요소)와
개발자의 앱이 상호작용하는 스레드 입니다.

따라서 Main 스레드는 **UI 스레드**라고 부르기도합니다.

그러나 특수한 상황에서 앱의 기본 스레드가 UI 스레드가 아닐 수도 있습니다. ([스레드 어노테이션](https://developer.android.com/studio/write/annotations?authuser=1#thread-annotations))

시스템은 컴포넌트의 각 인스턴스에 대하여 별도의 스레드를 생성하지 않습니다.
같은 프로세스에서 실행되는 모든 컴포넌트는 **UI 스레드 에서 인스턴스화** 되고
각 컴포넌트에 대한 시스템 호출은 해당 스레드(UI 스레드)에서 발송됩니다.

따라서 시스템 콜백에 응답하는 메서드(사용자 작업을 보고하는 ```onKeyDown()``` 또는 수명 주기 콜백 메서드)는 항상 프로세스의 **UI 스레드**에서 실행됩니다.

(UI 이벤트 루프를 구동하는 UI 스레드에서 처리)

예를 들어 사용자가 화면의 버튼을 터치하면, 앱 UI 스레드가 위젯에 터치 이벤트를 발송(디스패치)하고, 위젯은 눌린 상태를 설정한 뒤
이벤트 큐에 invalidate 요청을 게시합니다.
UI 스레드가 이 요청을 큐에서 제거하고 위젯에게 위젯을 다시 그려야 한다고 알려줍니다.

앱이 사용자 상호작용(인터렉션)에 응답하여 리소스를 많이 소모하는 작업을 수행하는 경우
이 단일 스레드 모델은 앱을 제대로 구현하지 않으면 낮은 성능을 보일 수 있습니다.

특히 모든 작업이 UI스레드에서 처리될 경우 네트워크 액세스나 데이터베이스 쿼리 등의 긴 작업을 수행할 때 전체 UI가 차단(block)됩니다.

**스레드가 blocking 되면 드로잉 이벤트를 포함하여 모든 이벤트가 발송되지 않습니다.**
(사용자에게는 앱이 중단된 것처럼 보입니다.)

더욱 심각한 경우, UI 스레드가 몇 초 이상 차단되면(현재 약 5초) 사용자에게
'애플리케이션 응답 없음'([ANR](https://developer.android.com/guide/practices/responsiveness.html?authuser=1)) 이라는 악명 높은 대화상자가 표시됩니다. (최악)

```
(Android에서는 Activity Manager 및 Window Manager 시스템 서비스에서 애플리케이션 응답성을 모니터링합니다.)

Android는 다음 조건 중 하나를 감지하면 애플리케이션에 대해 ANR 대화상자를 표시합니다.

- 입력 이벤트(예: 키 누름 또는 화면 터치 이벤트)에 5초 내에 응답하지 않음
- BroadcastReceiver가 10초 내에 실행을 완료하지 못함
```

그러면 사용자가 앱을 종료할 수도 있고, 불만족한 경우 앱을 제거할 수도 있습니다.

또한, Android UI 툴킷은 thread-safe 하지 않습니다. 따라서 UI를 작업자 스레드에서 조작해서는 안 됩니다.

UI 조작 작업은 모두 UI 스레드에서 해야만 합니다.

결론적으로 Android의 단일 스레드 모델에는 단순히 두 가지 규칙이 있습니다.

1. UI 스레드를 block 하지 말것
2. UI 스레드 외부에서 Android UI 툴킷에 액세스 하지 말것

## Worker threads

위에 설명한 단일 스레드 모델이 적용되기 때문에 앱 UI가 반응하기 위해서는
UI 스레드를 block 하지 않는 것이 매우 중요합니다.

작업은 해야하지만 즉각적인 조치가 필요하지 않은 작업일 경우, 반드시 별도의 스레드에서 수행해야합니다.
("background" or "worker" 스레드)

그러나 UI 스레드나 "Main" 스레드를 제외한 다른 스레드에서 UI를 업데이트할 수 없습니다.

이 문제를 해결하기 위해 Android는 다른 스레드에서 UI 스레드에 액세스하는 여러 가지 방식을 제공합니다.

- ```Activity.runOnUiThread(Runnable)```
- ```View.post(Runnable)```
- ```View.postDelayed(Runnable, long)```

```kotlin
fun onClick(v: View) {
  Thread(Runnable {
    // 잠재적으로 시간이 많이 걸리는 작업
    val bitmap = processBitMap("image.png")
    imageView.post {
      imageView.setImageBitmap(bitmap)
    }
  }).start()
}
```

이 구현은 스레드로부터 안전합니다.
네트워크 작업은 별도의 스레드에서 수행되는 반면 ImageView 는 언제나 UI 스레드에서 조작되기 때문입니다.

그러나 작업이 복잡해질수록 이런 종류의 코드가 더 복잡해질 수 있고 유지관리하기 까다로워질 수 있습니다.
더 복잡한 상호작용을 worker 스레드로 처리하려면,
작업자 스레드에서 ```Handler``` 를 사용하여 UI 스레드에서 전달받은 메세지를
처리하는 방안을 고려해봐야한다.

~~최선의 해결책은 ```AsyncTask``` 클래스를 확장하는 것일 수 있습니다.
이 방법은 UI와 상호작용해야 하는 worker 스레드 작업의 실행을 단순화합니다.~~

백그라운드 스레드에서 작업을 예약하고 UI 스레드와 다시 통신하는 방법에 대한 전체 설명은 [Android의 스레딩](https://developer.android.com/training/multiple-threads?authuser=1)을 참조하세요.

## Thread-safe methods

구현하는 매서드가 하나 이상의 스레드에서 호출되는 경우도 있습니다
따라서 이를 스레드로부터 안전하게 작성해야만 합니다.

이는 주로 원격으로 호출할 수 있는 메서드에 해당합니다.

예를 들어 [바인딩된 서비스](https://developer.android.com/guide/components/bound-services?authuser=1) 내의 메서드 등이 있습니다.

```IBinder```에 구현된 메서드에 대한 호출이 ```IBinder```가 실행되는 동일한 프로세스에서 발생할경우, 이 메서드는 호출자의 스레드에서 실행됩니다.

그러나 호출이 다른 프로세스에서 발생하면, 해당 메서드는 ```IBinder```와 동일한 프로세스에 유지되는 스레드 풀에서 선택된 스레드에서 실행됩니다. (프로세스의 UI 스레드에서 실행되지 않음)

예를 들어 어떤 서비스의 ```onBind()``` 메서드는 해당 서비스 프로세스의 UI 스레드에서 호출되고,
```onBind()``` 가 반환하는 객체에서 구현된 메서드 (예: RPC 메서드를 구현하는 하위 클래스)는 해당 풀 안의 여러 스레드에서 호출됩니다.
서비스에 클라이언트가 하나 이상 있을 수 있으므로 두 개 이상의 풀이 동시에 같은 ```IBinder``` 메서드에 참여할 수 있습니다. 그러므로 ```IBinder```메서드는 스레드로부터 안전하게 구현되어야 합니다.

마찬가지로 Content Provider 는 다른 프로세스에서 발생한 데이터 요청을 수신할 수 있습니다.

```ContentResolver``` 및 ```ContentProvider``` 클래스는 프로세스 간 통신의 세부적인 관리 정보는 숨기지만, 이러한 요청에 응답하는 ```ContentProvider``` 메서드 (즉, ```query()```, ```insert()```, ```delete()```, ```update()``` 및 ```getType()``` 메서드)는 프로세스의 UI스레드에서 호출되지 않고 Content Provider 프로세스의 스레드 풀에서 호출됩니다. 이러한 메서드가 동시에 몇 개의 스레드에서 호출될 수 있으므로, 스레드로 부터 안전하게 구현되어야 합니다.

## 프로세스 간 통신

Android는 원격 프로시저 호출(RPC)을 사용한 프로세스 간 통신(IPC) 메커니즘을 제공합니다. 여기서 메서드는 액티비티나 다른 앱 컴포넌트에 호출되지만 원격으로 (또 다른 프로세스에서) 실행되고 결과는 모두 호출자에게 반환됩니다. 

메서드 호출과 메서드의 데이터는 운영체제가 이해할 수 있는 수준으로 분해되어서, 로컬 프로세스와 주소 공간에서 원격 프로세스와 주소공간으로 전송된 다음 다시 결합되어 여기서 호출에 다시 응답합니다. 그런 다음 반환 값이 반대 방향으로 전송됩니다.

Android가 이와 같은 IPC 트랜잭션을 수행하는 데 필요한 코드를 제공하므로, 개발자는 RPC 프로그래밍 인터페이스를 정의하고 구현하는 데만 집중하면 됩니다.

IPC를 수행하려면 ```bindService()```를 사용하여 앱을 서비스에 바인드해야 합니다.
([서비스 개발자 가이드](https://developer.android.com/guide/components/services?authuser=1) 참고)