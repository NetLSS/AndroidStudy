# **스레드와 AsyncTask**

스레드의 개념에 대해서 되돌아보고 안드로이드에서 스레드는 어떻게 사용되는지 알아봅니다.

## **프로그램 & 프로세스 개요**

> 프로그램(Program) 이란?

- 컴퓨터가 실행할 수 있는 명령과 데이터의 집합이다.
- 명령과 데이터로 구성된 저장 장치에 저장된 실행 코드

파일형태로 저장되어있고 CPU에 의해서 메모리에 로딩되고 실행되게된다.

초기시절 컴퓨터는 프로그램을 단 하나만 실행할 수 있었지만 기술 발전을 통해 동시에 2개 이상 프로그램이 실행가능해 졌습니다.

그것을 우리는 멀티 프로그램 환경 이라고 부릅니다.

이후에는 운영체제의 빠른 발전으로 인해 컴퓨터 하드웨어가 직접 실행하던 구조에서 운영체제가 프로그램의 실행을 총괄하는 구조로 변화하게된다.

즉, 컴퓨터의 하드웨어 리소스들을 담당하는 운영체제가 프로그램 실행을관리하게 된 것.

이로써 물리영역(디스크)에 있는 프로그램을 논리공간(메모리)에서 실행하고, 이러한 리소스 관리를 운영체제가 하게되었습니다.

시스템의 리소스가 운영체제에 의해 관리되고 논리 공간에서 프로그램이 실행되기에 가능해진 것이 있습니다.

여러 개의 프로그램을 동시에, 하나의 프로그램을 동시에 여러개 실행이 가능해졌다는 점 입니다.

> 프로세스란?

- 현재 메모리에 로딩되어서 실행 중인 프로그램을 말합니다.
- 운영체제에 의해 메모리에 로딩되어 실행중인 프로그램



## **프로세스 & 스레드 개요**

운영체제에 의해 프로세스가 실행되면 프로세스는 코드 시작점 부터 종료지점 까지 순차적인 흐름을 가지게된다. (main 함수 등)

이때 하나의 순차적인 코드 흐름으로만 처리하기 힘든 작업이 생기게 되는데 이때
또 하나의 작업 흐름을 만들 수 있을 것이다.

즉, main() 함수와 작업 흐름이 구분되는 그리고 동시에 실행가능한 추가 흐름을 만들어서 두 가지 작업을 동시에 할 수 있다.

> 스레드란?

- 스레드는 프로세스 내부에서 순차적으로 실행되는 실행 흐름의 최소 단위이다.
- 프로세스 내에서 실행되는 각각의 독립적인 실행 흐름

> 멀티 스레드 프로그래밍 이란?

- 하나의 프로세스 내에서 두 개 이상의 스레드가 동작하도록 프로그래밍 하는 것

## **메인 스레드**

스레드는 프로세스 실행중에 언제든지 필요에 의해서 만들어지거나 실행될 수 있습니다

이때 **기존에 이미 실행중인 스레드에 의해서** 수행될 수 있습니다.

그러면 기존에 이미 실행중인 스레드가 프로세스가 실행 될 때 **최소 하나는 존재**해야한다는 의미로 해석될 수 있는데요

그것이 바로 main() 함수라고 부르는, 프로세스 시작과 동시에 실행되는 스레드인, **메인 스레드** 입니다.

프로세스 시작과 동시에 실행되고, 가장 중요한 스레드이기 때문에 **메인 스레드**라고 부르는 것이다.

그렇다고해서 모든 스레드가 메인 스레드에서만 실행되어야 하는 것은 아닙니다.

기존에 실행 중인 스레드 에서 실행 될 수 있기 때문에 메인 스레드를 제외한 **다른 스레드**에서도 실행이 가능합니다.

## **안드로이드 스레드(Android Thread)**

안드로이드 앱에서 스레드는 자바 SDK에 포함된 API를 사용하게 됩니다.

(관련 클래스는 ```java.lang.Thread``` 입니다.)

```Thread``` 클래스를 사용해 새로운 스레드를 생성하고 실행할 수 있습니다.

이때 두 가지 방법이 있는데,

첫 번째는 ```Thread``` 클래스를 확장(extends)하는 서브클래스(subclass)를 정의한 다음, ```Thread``` 클래스의 run() 메서드를 오버라이드(override) 하는 방법 (이후 ```run()```메서드 실행)

두 번째는 ```Runnable``` 인터페이스를 구현(implements) 하는 클래스를 정의한 다음, run() 매서드를 사용하는 방법입니다. (이후 ```Thread``` 클래스의 ```start()``` 메서드 실행)

### case 1 : Thread 클래스 확장

1. ```Thread``` 클래스 상속
2. ```run()``` 메서드 오버라이드
3. 정의한 자식 스레드 클래스 인스턴스 생성
4. ```start()``` 메서드 호출

코드 예시는 앞으로 코틀린을 사용하겠습니다.

```kotlin
class MyThread : Thread() {
    override fun run() {
        // TODO : 작업 코드
    }
}
val myThread = MyThread()
myThread.run()
```

### case 2 : Runnable 인터페이스 구현

1. ```Runnable``` 인터페이스 implements
2. ```run()``` 메서드 오버라이드
3. 자식 ```Runnable``` 클래스 인스턴스 생성 and ```Thread``` 클래스 인스턴스 생성
4. ```start()``` 메서드 호출

```kotlin
class MyRunnable : Runnable {
    override fun run() {
        TODO("작업 코드")
    }
}
val thread1 = Thread(MyRunnable())
thread1.start()
```

### **Thread 확장 vs Runnable 구현**

일단 두 방법을 사용해도 성능은 동일하다.

차이점은 단지 확장하는 경우에는 기존 Thread 클래스의 기능을 재정의, 추가 확장 하는 경우에 사용하기 적합하다.

자바는 다중상속을 지원하지 않기 때문에 우리의 클래스가 Thread 말고 다른 클래스를 상속해야 할 떄  Thread 를 상속하여 스레드를 정의하는 것은 불가능한일이 됩니다.

이때 사용 가능한 방법이 Runnable 이라는 스레드에서 반드시 구현해야하는 ```run()``` 메서드를 포함하는 인터페이스를 사용하는 방법입니다.

때문에 단순히 run 메서드만 구현하면 되는 경우 Runnable 을 사용하면 되겠습니다.

## **안드로이드 앱의 진입점 (Main Thread)**

안드로이드 앱의 진입점 즉 main 함수는 어디 있을까요?

먼저 자바 프로그램의 경우 반드시 main 함수를 구현해야 하는데 이는 JVM 이 자바 프로그램 실행 시 프로그램의 진입점인 main 함수를 찾아 실행하기 떄문입니다.

그렇다면 안드로이드 앱은 어떨까요?

안드로이드 에서도 자바를 사용하고 JDK로 빌드하기 때문에 main 함수가 필요합니다.

그러나 안드로이드 앱 개발 시에는 개발자가 직접 main 함수를 정의해줄 필요가 없습니다. 개발자는 앱에 포함된 액티비티 중에 하나를 런처(Launcher)로 지정함으로써 해당 액티비티를 앱의 시작접으로(entry point)로 만들 수 있습니다.

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest ...>

    <application
        ...>
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

메인 함수를 정의해주지 않았지만 사실 안드로이드 프레임워크에 이미 구현이 되어있습니다.

관련 클래스는 ```android.app.ActivityThread``` 이며, 메인 함수에서 여러 준비 동작을 실행합니다.

그 준비동작 중에서 중요한 작업은 바로 Main UI Thread 를 실행하는 것 입니다. 이후에 런처로 지정된 액티비티를 실행해주게 됩니다.

## **Android 의 Main UI Thread**

### 일반적인 UI 프레임워크에서의 Main UI Thread 

사용자의 입력(터치, 버튼 등)이 중요하게 생각되는 안드로이드 앱에서는 단순히 ```main()``` 함수의 시작부터 종료까지 선형으로 실행되지 않습니다.

그 대신 사용자의 입력 이벤트를 처리하기 위해 **이벤트 처리 루프(Loop)** 라는 녀석을 사용합니다.

루프라고 해서 무작정 ```for```문 ```while```문을 돌리는 것이 아니고 루프는 최대한 효율적으로 작동할 수 있도록 작성되어야 합니다.

그래서 UI 프레임워크는 **메세지 큐(Message Queue)** 라는 녀석을 사용해서 루프(Loop)를 작성하도록 가이드합니다.

**메세지 큐**는 말 그대로 Queue 자료구조를 사용합니다.

**메세지(Message)** 는 사용자 입력은 물론이고 시스템의 모든 이벤트를 전달할 때 사용되는 객체입니다.

스레드 관점에서 보면 **메세지 큐**는 시스템 이벤트를 발생한(전송 받은) 순서대로 전달 받아 처리하는 구조를 의미합니다.

시스템 or 프로세스 에서 발생한 메세지가 메세지 큐에 수신되면, 메세지가 담고 있는 내용에 따라 적합한 핸들러(Handler) 메서드가 호출됩니다.

이때 모든 앱이, 시스템에서 발생 하는 모든 이벤트를 처리할 필요까지는 없기 때문에, 관심을 가지는 이벤트의 메세지에 대해서만 핸들러를 등록하고 처리하도록 합니다.

## 안드로이드 앱의 메인 UI 스레드

안드로이드 또한 일반적인 UI 프레임워크에서 크게 벗어나지 않으며, **Loop 와 Handler 역할을 하는 클래스 구현**을 통해 메인 UI 스레드를 작성할 수 있도록 해준다.

### Looper 와 Handler

**Looper**

안드로이드 앱에서 이벤트 처리를 위한 루프는 ```Looper``` 라는 클래스를 통해 실행된다.

```Looper``` 는 루프를 실행하고 루프 안에서 메세지 큐로 전달되는 **메세지**가 있는지 쳐다보고 있게 된다.

쳐다 보다가 새로운 메세지가 도착하면 해당 메세지를 처리할 **핸들러**를 호출하게된다.

**Handler**

안드로이드 핸들러는 ```Handler``` 클래스가 담당합니다.

그러나 일반적으로 알려진 핸들러와는 좀 다르게 안드로이드의 핸들러는 메세지만 처리하는 것이 아닌 **메세지를 보내는 역할 까지 포함**합니다.

안드로이드의 Handler 는 Lopper 가 가진 메세지 큐를 다룰 수 있어서 **새로운 메세지를 보내거나**, **수신된 메세지에 대한 처리**를 담당하는 주체가됩니다.

## 안드로이드 메인 UI 스레드의 역할

안드로이드 앱의 메인 UI 스레드는 타 GUI 프레임워크와 마찬 가지로 여러 구성 요소들을 **화면에 그리는 역할**을 수행하게 됩니다. (여러 작업을 수행할 수 있지만, 그리기 역할은 매우 중요한 역할에 해당한다.)

이때 가장 중요한 원칙이 나오는데 GUI 프레임워크의 **그리기 수행은 반드시 메인 UI 스레드 에서만 실행 되어야 한다**는 점 입니다.

그 이유는 여러 스레드에서 UI 그리기 작업을 진행한다면 타이밍 문제 등이 발생 할 수 있어서 입니다.

(또, 안드로이드 UI 툴킷이 **thread-safe** 하지 **않기** 때문)