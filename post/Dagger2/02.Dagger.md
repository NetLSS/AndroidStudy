# Dagger

모든 애플리케이션에서 최고의 클래스는 다음과 같은 작업을 수행하는 클래스입니다: `BarcodeDecoder`, `KoopaPhysicsEngine` 및 `AudioStreamer`. 이러한 클래스에는 종속성이 있습니다. 아마도 `BarcodeCameraFinder`, `DefaultPhysicsEngine` 및 `HttpStreamer`일 것입니다.

대조적으로, 모든 응용 프로그램에서 최악의 클래스는 많은 작업을 수행하지 않고 공간을 차지하는 클래스입니다: `BarcodeDecoderFactory`, `CameraServiceLoader` 및 `MutableContextWrapper`. 이 클래스는 흥미로운 것들을 함께 연결하는 서투른 덕트 테이프입니다.

Dagger는 보일러 플레이트를 작성하는 부담 없이 종속성 주입 디자인 패턴을 구현하는 이러한 FactoryFactory 클래스를 대체합니다. 그래서 개발자가 중요한 일에만 집중할 수 있습니다. 종속성을 선언하고 이를 충족하는 방법을 지정하고 앱을 출시하세요.

표준 javax.inject 주석(JSR 330)을 기반으로 하여 각 클래스를 쉽게 테스트할 수 있습니다. RpcCreditCardService를 FakeCreditCardService로 교체하기 위해 많은 상용구가 필요하지 않습니다.

의존성 주입은 테스트만을 위한 것이 아닙니다. 또한 재사용 가능하고 교체 가능한 모듈을 쉽게 생성할 수 있습니다. 모든 앱에서 동일한 AuthenticationModule을 공유할 수 있습니다. 또한 개발 중에는 DevLoggingModule을 실행하고 프로덕션에서는 ProdLoggingModule을 실행하여 각 상황에서 올바른 동작을 얻을 수 있습니다.

## Why Dagger 2 is Different


종속성 주입 프레임워크는 구성 및 주입을 위한 다양한 API와 함께 수년 동안 존재해 왔습니다. 그렇다면 바퀴를 재발명하는 이유는 무엇입니까? Dagger 2는 **생성된 코드로 전체 스택을 구현한 최초의 제품**입니다. 기본 원칙은 종속성 주입이 가능한 한 간단하고 추적 가능하며 성능이 좋은지 확인하기 위해 사용자가 손으로 작성한 코드를 모방하는 코드를 생성하는 것입니다. 디자인에 대한 자세한 내용은 Gregory Kick의 이 강연(슬라이드)을 시청하십시오.

## Using Dagger

우리는 커피 메이커를 구축하여 의존성 주입과 Dagger를 시연할 것입니다. 컴파일하고 실행할 수 있는 전체 샘플 코드는 Dagger의 커피 예제를 참조하세요.

### Declaring Dependencies

Dagger는 애플리케이션 클래스의 인스턴스를 구성하고 해당 종속성을 충족합니다. javax.inject.Inject 주석을 사용하여 관심 있는 생성자와 필드를 식별합니다.

@Inject를 사용하여 Dagger가 클래스의 인스턴스를 생성하는 데 사용해야 하는 생성자에 주석을 달 수 있습니다. 새 인스턴스가 요청되면 Dagger는 필수 매개변수 값을 얻고 이 생성자를 호출합니다.

```java
class Thermosiphon implements Pump {
  private final Heater heater;

  @Inject // 생성자애 inject 주석
  Thermosiphon(Heater heater) {
    this.heater = heater;
  }

  ...
}
```

Dagger는 필드를 직접 주입할 수 있습니다. 이 예에서는 히터 필드에 대한 Heater 인스턴스와 펌프 필드에 대한 Pump 인스턴스를 얻습니다.

```java
class CoffeeMaker {
  @Inject Heater heater;
  @Inject Pump pump;

  ...
}
```

클래스에 @Inject 주석 필드가 있지만 @Inject 주석 생성자가 없는 경우 Dagger는 요청 시 해당 필드를 삽입하지만 새 인스턴스를 생성하지는 않습니다. Dagger가 인스턴스도 생성할 수 있음을 나타내기 위해 @Inject 주석과 함께 인수가 없는 생성자를 추가하십시오.

Dagger는 메서드 주입도 지원하지만 일반적으로 생성자 또는 필드 주입이 선호됩니다.

@Inject 주석이 없는 클래스는 Dagger로 생성할 수 없습니다.

### 의존성 충족

기본적으로 Dagger는 위에서 설명한 대로 요청된 유형의 인스턴스를 구성하여 각 종속성을 충족합니다. CoffeeMaker를 요청하면 new CoffeeMaker()를 호출하고 주입 가능한 필드를 설정하여 얻을 수 있습니다.

그러나 @Inject는 모든 곳에서 작동하지 않습니다.

- 인터페이스를 구성할 수 없습니다.
- 제3자(third party) 클래스는 주석을 달 수 없습니다.
- 구성 가능한 개체를 구성해야 합니다!

@Inject가 충분하지 않거나 어색한 경우 @Provides-annotated 메서드를 사용하여 종속성을 충족합니다. 메서드의 반환 유형은 충족하는 종속성을 정의합니다.

예를 들어, 히터가 필요할 때마다 providerHeater()가 호출됩니다.

```java
@Provides static Heater provideHeater() {
  return new ElectricHeater();
}
```

@Provides 메소드가 자체적으로 종속성을 가질 수도 있습니다. 예를 들어 ElectricHeater에는 @Inject 생성자가 있으므로 위의 메서드를 다음과 같이 대신 작성할 수 있습니다.

```java
@Provides static Heater provideHeater(ElectricHeater heater) {
  return heater;
}
```

이런 식으로 Dagger는 ElectricHeater 인스턴스화를 처리하고 @Provides 메서드는 Heater 유형에 별칭을 지정하는 데만 사용됩니다.

이 특별한 경우에는 `@Binds` 메서드를 사용하여 별칭을 정의하여 더 단순화할 수 있습니다. `@Provides`와 달리 `@Binds` 메서드는 추상적이고 **구현이 없습**니다.

(ElectricHeater 에는 @Inject 생성자가 있으므로 bind를 사용하여 아래처럼 표현이 가능함.)

```java
@Binds Heater bindHeater(ElectricHeater impl);

```

> 참고: @Binds를 사용하는 것은 별칭(alias)을 정의하는 데 선호되는 방법입니다. Dagger는 컴파일 시간에만 모듈이 필요하고 런타임에 모듈을 로드하는 클래스를 피할 수 있기 때문입니다.

(울 회사에서 쓰는 DI 중에 viewModel 을 DI 하는 경우 직접 뷰모델 팩토리를 주입받고,
거기에 더해 Provides 에서 각 (연결된)액티비티와, 뷰모델 팩토리를 파라미터로 갖는 Provider로 `ViewModelProvider(activity, viewModelFactory).get()` 으로 뷰모델을 주입하여 viewModel 필드에 바로 Injection 이 가능하다.)

[dagger2 android viewmodel 과 사용하기](https://trend21c.tistory.com/2111)
[https://www.charlezz.com/?p=1315](Dagger2를 알아보자 – Multibinding)
[DAGGER2 @Binds](https://kotlinworld.com/106)