# Fully Functional – Embracing Functional Programming

함수형 프로그래밍은 개발자가 순수한 수학적 연산을 통해 데이터와 비즈니스 로직을 모델링할 수 있도록 도와줌으로써 현대의 객체 지향 코드에서 가장 큰 과제 중 하나인 상태 관리를 제한하기 때문에 확장 가능한 애플리케이션을 작성하는 강력한 도구가 될 수 있다.

이 장에서는 독자에게 코틀린과 함께 함수형 프로그래밍을 달성하는 방법에 대해 더 잘 이해할 수 있도록 제공할 것입니다. 함수형 프로그래밍의 몇 가지 이점에 대해 살펴보고, 코틀린이 최상위 및 고차 함수를 통해 어떻게 지원하는지 살펴본 다음, 코틀린 표준 라이브러리와 화살표를 사용하여 더 많은 함수형 코드를 작성하는 방법에 대해 알아보겠습니다.

이 장은 다음과 같이 세분화됩니다.

- 함수형 프로그래밍의 특성 및 이점
- 고차 함수 쓰기
- 코틀린 표준 라이브러리 활용
- 화살표를 사용한 기능 프로그래밍

[깃허브 저장소](https://github.com/PacktPublishing/Mastering-Kotlin/tree/master/Chapter12)

## Understanding functional programming

3장 '코틀린의 프로그래밍 패러다임 이해'에서 살펴본 것처럼 함수형 프로그래밍은 순수한 수학적 함수를 이용해 프로그램이 표현되는 선언형 프로그래밍 패러다임이다. 이 섹션에서는 이것이 실제로 무엇을 의미하는지, 그리고 왜 Kotlin의 함수형 프로그래밍을 도입하고자 하는지 알아보겠습니다.

# Pure functions

함수 프로그래밍의 핵심 교의 중 하나는 순수 함수의 적용을 통한 데이터의 변환이다. 함수 프로그래밍의 가장 엄격한 정의에 따르면, 이러한 순수 함수는 수학적 연산으로 표현된다. 함수형 프로그래밍의 순수하고 수학적 특성은 다음과 같은 두 가지 흥미로운 특성을 낳는다.

변수의 불변성
적은 부작용 

기능 코드의 이러한 속성은 Kotlin 또는 다른 언어로 코드를 작성할 때 큰 도움이 될 수 있으며 다음 섹션에서 두 가지 모두에 대해 살펴보겠습니다.

## Immutability

프로그램을 구축하는 것은 복잡한 상태를 모델링하고 관리하는 연습이 되기도 합니다. 객체 지향 프로그래밍이 이 상태를 더 쉽게 모델링할 수 있지만 데이터 동기화 및 일관성 문제를 일으킬 수 있다. 상태를 나타내는 모델이 언제든 변경될 수 있다면 주어진 애플리케이션의 현재 상태를 추론하는 것이 더 어려워진다. 상태를 언제 어디서 조작하고 있는지, 상태를 어떻게 수정하는 것이 최선인지조차 이해하기 어려워진다.

함수 코드 내에서 변수와 상태의 불변성이 매력적인 이유다. 만약 우리의 상태를 나타내는 모델이 불변이라면, 상태를 만들거나 수정하는 계약은 훨씬 더 명확해진다. 새로운 상태를 나타내려면, 우리는 그 상태를 유지할 새로운 모델을 만들어야 합니다. 이제 주어진 변수의 정적이고 변하지 않는 상태에 의존할 수 있기 때문에 추적하기가 더 쉬워진다.

이는 함수형 프로그래밍의 다음 유용한 특성인 제한된 부작용과 짝을 이룰 때 더욱 관련이 깊어진다.

## Limited side effects

순수 수학 함수는 부작용이 발생하지 않는다. 프로그래밍 세계에서, 이것은 주어진 함수를 호출하면 단일 출력이 생성되고 다른 작업은 하지 않는다는 것을 의미한다. 순수 함수는 전역 상태 조작, 네트워크 요청, 데이터베이스 업데이트 등의 작업 없이 출력을 반환합니다.

부작용을 낳지 않는 함수를 작성함으로써 다시 데이터 흐름과 애플리케이션의 상태가 어떻게 표현되고 조작되는지 추론하기 쉽게 만들고 있다. 함수가 단일 명시적 작업에 초집중적일 때, 상태가 어떻게 수정되는지를 이해하는 것이 훨씬 쉬워진다.

# Reduced complexity

우리 프로그램의 불변성과 부작용의 제한은 그 프로그램들의 복잡성을 줄이는 데 효과가 있다. 어떤 코드 베이스들은 필요 이상으로 복잡하다; 문제 자체는 복잡하다. 그러나 상태가 어떻게 표현, 관리 또는 조작되는지 더 이상 명확하지 않기 때문에 많은 코드 베이스가 복잡해진다. 기능적 프로그래밍이 큰 이점을 얻을 수 있는 곳이 바로 이와 같은 경우입니다.

기능 코드를 코틀린으로 작성하면 다음과 같은 여러 가지 방법으로 복잡성을 줄일 수 있습니다:

- Kotlin은 데이터 클래스를 사용하여 불변성을 적용할 수 있게 해줍니다. 데이터 클래스를 사용하면 상태를 나타내는 불변 모델을 매우 쉽게 정의할 수 있습니다. 다음은 UI의 현재 상태를 나타내는 불변 데이터 클래스를 정의한 예입니다:

```kt
data class ViewState(val title: String, val subtitle: String)
```

또한 Kotlin은 이전 상태를 기반으로 새 상태를 만들 수 있는 편리한 구문을 제공합니다. 이 작업은 데이터 클래스에 대해 생성된 복사 생성자와 함께 명명된 인수를 사용하여 수행할 수 있습니다. 다음 코드를 생각해 보십시오.

```kt
val initialState = ViewState("Hello", "Kotlin")
val updatedState = initialState.copy(title = "Hey There!")
```

  이 코드에서는 제목 속성을 "Hey There!" 값으로 바꾸면서 initialState 변수의 복사본을 만들 수 있습니다. 이를 통해 기존 상태를 수정하지 않고도 원하는 제목 속성을 명시적으로 업데이트할 수 있습니다.

코틀린은 최상위 함수를 지원하기 때문에 유용한 메서드/함수를 포함하는 것 외에 다른 목적을 제공하지 않는 유틸리티 및 도우미 클래스의 생성을 방지함으로써 코틀린 코드 베이스의 복잡성을 줄일 수 있다. 예를 들어, Java에는 다음과 같이 구현되는 DateHelpers라는 클래스가 있을 수 있습니다.

```java
class DateHelpers {
    private static final String pattern = "MM-dd-yyyy";
    
    public String formatDateForUI(Date date) {
        SimpleDateFormat simpleDateFormat = new 
          SimpleDateFormat(pattern);
        return simpleDateFormat.format(date);
    }
}
```

그러나 Kotlin에는 최상위 함수가 있으며 정적 메소드를 포함하는 클래스를 명시적으로 만들 필요 없이 동일한 함수를 구현할 수 있습니다. 이와 동일한 기능의 코틀린 구현은 다음과 같을 수 있습니다.

```kt
private const val pattern = "MM-dd-yyyy"
fun formatDateForUI(date: Date): String {
    val simpleDateFormat = SimpleDateFormat(pattern)
    return simpleDateFormat.format(date)
}
```

이러한 불변성 적용, 편리하고 명시적인 데이터 클래스 복사 및 도우미 클래스 감소는 코드베이스 내의 복잡성을 줄이는 데 도움이 될 수 있다. 코틀린이 함수 프로그래밍을 지원하고 그 지원의 혜택을 받는 가장 큰 방법 중 하나는 고차 함수 지원을 통해서이다. 다음 섹션에서는 고차 함수가 코틀린의 함수 프로그래밍을 어떻게 개선하는지 살펴보겠습니다.