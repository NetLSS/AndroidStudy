# Benefits of using Hilt

왜 힐트를 사용합니까?

- 상용구 감소
- 분리된 빌드 종속성
- 단순화된 구성
- 향상된 테스트
- 표준화된 components

## Reduced boilerplate

Hilt의 목표는 사용자가 Dagger 설정의 나머지 부분에 대해 걱정할 필요 없이 Dagger 바인딩 정의 및 사용법에 집중할 수 있도록 하는 것입니다. 즉, 모듈 및 인터페이스 목록이 있는 component 정의, 수명 주기의 올바른 지점에서 구성 요소를 만들고 유지하는 코드, 상위 구성 요소를 가져오기 위한 인터페이스 및 캐스트 등과 같은 것을 숨깁니다.

일부 단순성은 모놀리식 구성 요소를 사용하는 Hilt에서도 나옵니다(즉, 모든 활동에 단일 구성 요소 사용, 모든 조각에 단일 구성 요소 사용 등). Hilt는 기본적으로 전역 바인딩 네임스페이스를 권장하므로 어떤 활동이나 조각에서 주입되었는지 추적하지 않고도 어떤 바인딩 정의가 사용되는지 쉽게 알 수 있습니다. 이 디자인 결정에 대한 자세한 내용은 [여기](https://dagger.dev/hilt/monolithic.html)를 읽어보세요.

## Decoupled build dependencies

Dagger를 순진하게 사용하면 코드가 Dagger 구성 요소를 직접 참조하는 경우 빌드 문제가 발생할 수 있습니다. 이러한 문제는 Dagger 구성 요소에 설치된 모든 모듈에 대한 참조가 있기 때문에 발생합니다. 이로 인해 빌드 속도가 느려지는 종속성이 커질 수 있습니다. 이를 해결하는 자연스러운 방법에는 인터페이스와 안전하지 않은 캐스트가 포함됩니다. 런타임 오류가 발생할 수 있기 때문에 이것은 절충안입니다. 예를 들어, 새로운 인젝터 인터페이스를 도입하면 컴포넌트에 직접 의존하는 것을 피할 수 있지만 컴포넌트가 인젝터 인터페이스를 확장하는 것을 잊어버리면 캐스트 예외가 발생합니다.

(unsafe casts)

인터페이스, 안전하지 않은 캐스트 및 모듈/인터페이스 목록을 후드 아래에서 생성하는 코드를 통해 Hilt는 코드 생성 및 모듈/진입점 검색의 보장으로 인해 이러한 런타임 안전하지 않은 캐스트를 안전하게 만듭니다.

## Configuration

앱에는 기능이 다른 프로덕션 또는 개발 빌드와 같이 빌드 구성이 다른 경우가 많습니다. 이러한 다양한 기능 집합은 종종 다른 Dagger 모듈 집합을 의미합니다. 일반 Dagger 빌드에서 다른 모듈 세트에는 일반적으로 많은 부분이 반복되는 별도의 구성 요소 트리(모든 범위에 대해 별도의 구성 요소)가 있어야 합니다. Hilt는 빌드 종속성을 통해 모듈을 설치하고 코드는 구성 요소를 생성하므로 빌드의 다른 특징을 만드는 것은 추가 또는 제거된 종속성을 사용하여 컴파일하는 것만큼 간단합니다.

## Testing

Dagger로 테스트하는 것은 위에서 언급한 구성 문제로 인해 어려울 수 있습니다. Hilt는 마찬가지로 구성 요소의 코드 생성으로 인해 테스트 모듈 및 바인딩을 쉽게 변경할 수 있습니다. Hilt에는 모듈을 관리하고 테스트에서 Dagger를 사용할 수 있도록 테스트 바인딩을 더 쉽게 제공하는 특정 테스트 유틸리티가 내장되어 있습니다. 테스트에서 Dagger를 사용하면 테스트에서 상용구를 줄이는 데 도움이 되며 프로덕션에서 인스턴스화되는 것과 동일한 방식으로 코드를 인스턴스화하여 테스트를 더욱 강력하게 만듭니다.

## Standardization

Hilt는 [구성 요소 계층을 표준화](https://dagger.dev/hilt/components.html#component-heirarchy)합니다. 이는 Hilt와 통합되는 라이브러리가 이러한 알려진 구성 요소의 바인딩을 쉽게 추가하거나 사용할 수 있음을 의미합니다. 이를 통해 Hilt 앱에 더 간단하고 명확하게 통합할 수 있는 더 복잡한 라이브러리를 구축할 수 있습니다.
